todo:
* make an option which when on then when currently focused window is fullscreen or borderless fullscreen (if detectable ofc) then don't try to use the gestures ie. bypass the code checking for them, so for example: winkey held down code won't activate, this way, any kind of theoretical slowdown on input(due to calls to getasyncstate or saving/reading atomic bools) will be removed. - it's more expensive than just checking for keys to activate, if I do it in the same place (in hooks), but maybe if I do it in some specific on focus hook then it would work.
* re: focus the drag-moved window first, "Your Current Method: Injected LMB avoids attachment(to target window's thread) but risks UI interactions (e.g., clicking a button starts an action). Attachment + SetForegroundWindow is cleaner for focus-only, no click side effects.", but this means the hooks must be in their own thread to not lock things up. Kept so far as 1 thread and seems to be working, but unclear how correct this is with respect to potential hangs due to target window hanging.
* see if SW_RESTORE works for when window is maximized!
* could maybe check if "crossing DPI monitors mid-drag (system handles)" messes up the coords during drag, for manual or native move. If so find a fix.
* make sure hooks are on their own thread, different from msg. loop thread, to avoid lockups; use windows.GetCurrentThreadId() to check they're diff. threads; test with GOMAXPROCS=1; "you can force more threads via runtime.GOMAXPROCS(runtime.NumCPU())" and make sure it's at least 2 even if numCPU is less;

done:
//they can be moved * see if child windows or dialogs like the LAN adapter config. can be moved and how.
//* FIXME: winkey+L will make prog think winkey is held after unlock!
//fixed printing was blocking thus our hooks weren't running //* ensure when runasadmin.bat and LMB-dragging scrollbar of that cmd.exe (admin) the mouse movements aren't 500ms delayed - probably need to use separate thread for hooks(+ their own msg.loop). This only happened in devbuild.bat not in build.bat btw.
//done//* tooltip not showing on warnings for lines in vscode, this was due to keyboard spamming keys (known keyboard bug)
//done//* while waiting for Enter key to exit, unregister mutex right before that.
//* native window dragging is broken currently, ie. if you uncheck "Manual move(no focus)" in systray that means native drag is used but it only works sometimes and it's pretty bad/choppy when it does work on cmd.exe due to the 1 thread of our program (for msg. loop and hooks, same thread) and cmd.exe does something (like selection started) which hangs our program thus the hooks too and Windows times out the hooks that's why it's not fully locked up.
//* currently native drag attempt on tcmd fails the first time then works 90% of the time but if tcmd then quits (not mid-drag, just normally when idle) then native drag on the newly started tcmd will fail 99.99% of the time!
//* native drag seems to need: attach thread, focus target window, send the SC_MOVE, send the WM_LBUTTONDOWN to prevent LListBox aka child from receiving it from the LMBDown that's next, then inject LMBDown because it needs the get async state for LMB to be DOWN! This works but not if you restart tcmd without also restarting winbollocks, which is positively odd.
//done//* give up on native drag due to so flakey, jesus; keep only manual drag.
//done4winkey//* winkey+L while dragging(ie. winkey+LMBdrag is down and dragging) will cause the subsequent winkeyUP and LMB UP to not be seen by my app due to being in lock screen when they happen, thus when unlocked, my app is still in drag mode, well winkeyUP is detected via get async state so it stops but LMB UP is never detected because LMB DOWN was eaten when it happened so can't query async state for LMB because it's never down during drag (got eaten and async state says it's thus UP) so while it stops due to winkey being UP if it is down for any reason it won't know to stop because LMB is physically UP in this case. So if we ever decide to allow the case when winkey+LMB starts the gesture but then we can allow winkeyUP to continue the dragging gesture until LMB is released(aka UP) then in this winkey+L happening during drag case, then unlocking session even tho LMB is UP the dragging continues as if it is still down!
//done//* ensure the focus via thread attach and focus via LMB are two systray menu options and not chained so the LMB doesn't click on items in start menu because it's the fallback and i know normal(thread attach) focusing fails for this case.
//done//* drags don't happen(are queued actually) when systray popup menu is open, likely due to single-threaded-ness! can test channel peak events this way (1179 got first time, 0 dropped tho). The previous implementation relied on PostThreadMessage to send a thread-level doorbell (WM_DO_SETWINDOWPOS) with HWND=0, which the modal message loop inside TrackPopupMenu would dequeue but then silently discard when calling DispatchMessage—because DispatchMessage ignores messages with a null HWND and does not invoke any window procedure for them; as a result, drainMoveChannel() never ran while the context menu was open, allowing move events to pile up unchecked in the buffered channel (thanks to the low-level mouse hook continuing to enqueue them), and only when a fresh drag gesture began after the menu closed did a new doorbell get posted and processed normally in the main GetMessage loop, triggering a massive single burst of backlog processing that made the window suddenly snap through every queued position. By switching to PostMessage targeted at your own hidden message-only window (trayIcon.HWnd ≠ 0), the doorbell becomes a proper window message; now, even during the modal popup, TrackPopupMenu’s internal loop dequeues it, recognizes it as non-menu-related, calls DispatchMessage, and your wndProc handles WM_DO_SETWINDOWPOS by draining the channel in near real-time, preventing any significant buildup and ensuring smooth, responsive window movement regardless of whether the systray context menu is open—thus eliminating the delayed flood behavior entirely while keeping the single-threaded Win32 architecture intact and avoiding re-entrancy risks in practice (since new WM_MYSYSTRAY triggers typically close the existing popup first).

